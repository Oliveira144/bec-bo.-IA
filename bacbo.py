import streamlit as st
import pandas as pd
import datetime

# --- Configura√ß√£o da P√°gina ---
st.set_page_config(
    page_title="Bac Bo Predictor üé≤",
    layout="wide",
    initial_sidebar_state="collapsed",
    menu_items={
        'About': 'Este aplicativo ajuda a analisar padr√µes no jogo Bac Bo da Evolution Gaming.'
    }
)

# --- Inicializa√ß√£o do Estado da Sess√£o ---
# Usamos st.session_state para manter o estado do app entre as intera√ß√µes
if 'historico' not in st.session_state:
    st.session_state.historico = []
if 'green_count' not in st.session_state:
    st.session_state.green_count = 0
if 'red_count' not in st.session_state:
    st.session_state.red_count = 0
if 'g1_active' not in st.session_state:
    st.session_state.g1_active = False
if 'last_suggested_entry' not in st.session_state:
    st.session_state.last_suggested_entry = None
if 'rodadas_desde_ultimo_empate' not in st.session_state:
    st.session_state.rodadas_desde_ultimo_empate = 0
if 'empates_recentes' not in st.session_state:
    st.session_state.empates_recentes = 0 # Para controle de hor√°rios ruins (ex: 3 empates em 10 rodadas)
if 'count_dado_1_consecutivo' not in st.session_state:
    st.session_state.count_dado_1_consecutivo = 0

# --- Fun√ß√µes Auxiliares ---
def get_winner(player_sum, banker_sum):
    """Determina o vencedor da rodada."""
    if player_sum == banker_sum:
        return 'Empate'
    elif player_sum > banker_sum:
        return 'Player'
    else:
        return 'Banker'

def detectar_padroes(historico_completo):
    """
    Fun√ß√£o placeholder para detec√ß√£o de padr√µes.
    Esta fun√ß√£o seria expandida para conter a l√≥gica dos 30 padr√µes.
    Por enquanto, retorna um padr√£o gen√©rico e uma sugest√£o.

    CORRE√á√ÉO: Adicionado tratamento para hist√≥rico vazio/poucos elementos
    e corre√ß√£o da chave 'Vencedor'.
    """
    # Se o hist√≥rico estiver vazio, n√£o h√° padr√µes para detectar
    if not historico_completo:
        return "Nenhum Padr√£o Detectado", None, 0 # Nome do padr√£o, Sugest√£o (Player/Banker), Confian√ßa

    # Sempre podemos pegar o √∫ltimo resultado se o hist√≥rico n√£o estiver vazio
    ultimo_resultado = historico_completo[-1]['Vencedor'] # USANDO 'Vencedor' com 'V' mai√∫sculo

    # Padr√£o 1: Altern√¢ncia Simples (Player/Banker intercalado)
    if len(historico_completo) >= 2:
        segundo_ultimo_resultado = historico_completo[-2]['Vencedor'] # USANDO 'Vencedor'
        if ultimo_resultado != 'Empate' and segundo_ultimo_resultado != 'Empate' and \
           ultimo_resultado != segundo_ultimo_resultado:
            sugestao = 'Banker' if ultimo_resultado == 'Player' else 'Player'
            return "1. Altern√¢ncia Simples", sugestao, 70 # 70% de confian√ßa para este exemplo

    # Padr√£o 2: Sequ√™ncia de 2
    if len(historico_completo) >= 2 and ultimo_resultado != 'Empate':
        if historico_completo[-1]['Vencedor'] == historico_completo[-2]['Vencedor']: # USANDO 'Vencedor'
            sugestao = ultimo_resultado
            return "2. Sequ√™ncia de 2", sugestao, 75 # 75% de confian√ßa
    
    # Padr√£o 3: Sequ√™ncia de 3
    if len(historico_completo) >= 3 and ultimo_resultado != 'Empate':
        if (historico_completo[-1]['Vencedor'] == historico_completo[-2]['Vencedor'] and
            historico_completo[-2]['Vencedor'] == historico_completo[-3]['Vencedor']):
            sugestao = 'Banker' if ultimo_resultado == 'Player' else 'Player' # Revers√£o
            return "3. Sequ√™ncia de 3", sugestao, 80 # 80% de confian√ßa

    # Padr√£o Ouro (placeholder - voc√™ implementaria a l√≥gica complexa aqui)
    # Por exemplo, se uma sequ√™ncia espec√≠fica de 5 rodadas se repetisse
    # if detectar_padrao_ouro_real(historico_completo): # Esta fun√ß√£o seria sua l√≥gica avan√ßada
    #    return "üîí Padr√£o Ouro", "Player", 95 # Alt√≠ssima confian√ßa

    # Se nenhum padr√£o forte for detectado com alta confian√ßa
    return "Nenhum Padr√£o Forte", None, 0

def analisar_sugestao(historico):
    """
    Analisa os padr√µes e retorna a melhor sugest√£o com confian√ßa.
    Prioriza a sugest√£o em modo G1 se estiver ativo.
    """
    # Se o modo G1 estiver ativo, a sugest√£o √© a √∫ltima feita
    if st.session_state.g1_active and st.session_state.last_suggested_entry:
        # A confian√ßa √© 100% no modo G1 para indicar que a aposta √© fixa
        return "Modo G1 Ativo", st.session_state.last_suggested_entry, 100, True

    # Pega o nome do padr√£o, sugest√£o e confian√ßa da fun√ß√£o de detec√ß√£o
    nome_padrao, sugestao, confian√ßa_base = detectar_padroes(historico)
    
    # Apenas sugere se a confian√ßa for alta o suficiente (definido no return de detectar_padroes)
    if sugestao and confian√ßa_base >= 70: # Ajuste o limite de confian√ßa conforme seus padr√µes
        return nome_padrao, sugestao, confian√ßa_base, False
    
    return "Aguardando Padr√£o Forte", None, 0, False # N√£o h√° sugest√£o com alta confian√ßa

def atualizar_contadores_horarios(player_dado1, player_dado2, banker_dado1, banker_dado2, winner):
    """Atualiza contadores para detec√ß√£o de hor√°rios cr√≠ticos."""
    # Contar rodadas desde o √∫ltimo empate
    if winner == 'Empate':
        st.session_state.rodadas_desde_ultimo_empate = 0
        st.session_state.empates_recentes += 1 # Incrementa para controle de empates pr√≥ximos
    else:
        st.session_state.rodadas_desde_ultimo_empate += 1
        # Se n√£o √© empate, reseta o contador de empates recentes, a menos que haja uma l√≥gica para "3 empates em 10 rodadas"
        # que precise de um hist√≥rico mais longo
        st.session_state.empates_recentes = 0 # Reinicia se a sequ√™ncia de empates foi quebrada

    # Contar dado '1' consecutivo (em qualquer dado)
    if 1 in [player_dado1, player_dado2, banker_dado1, banker_dado2]:
        st.session_state.count_dado_1_consecutivo += 1
    else:
        st.session_state.count_dado_1_consecutivo = 0


# --- T√≠tulo do App ---
st.title("üé≤ Bac Bo Predictor - Guia de Padr√µes")
st.markdown("---")

# --- Painel de Entrada de Dados ---
st.header("Adicionar Nova Rodada ao Hist√≥rico")

col_input1, col_input2 = st.columns(2)

with col_input1:
    st.subheader("üîµ Player")
    player_dado1 = st.number_input("Dado 1 do Player", min_value=1, max_value=6, value=1, key="pd1")
    player_dado2 = st.number_input("Dado 2 do Player", min_value=1, max_value=6, value=1, key="pd2")

with col_input2:
    st.subheader("üî¥ Banker")
    banker_dado1 = st.number_input("Dado 1 do Banker", min_value=1, max_value=6, value=1, key="bd1")
    banker_dado2 = st.number_input("Dado 2 do Banker", min_value=1, max_value=6, value=1, key="bd2")

add_round_button = st.button("‚ûï Adicionar Rodada e Analisar", use_container_width=True)

if add_round_button:
    player_sum = player_dado1 + player_dado2
    banker_sum = banker_dado1 + banker_dado2
    winner = get_winner(player_sum, banker_sum)

    # Armazena os dados da rodada no hist√≥rico
    # Certifique-se de que o nome da chave para o vencedor √© 'Vencedor' (com V mai√∫sculo)
    st.session_state.historico.append({
        "Rodada": len(st.session_state.historico) + 1,
        "Player Dados": f"[{player_dado1},{player_dado2}]",
        "Player Soma": player_sum,
        "Banker Dados": f"[{banker_dado1},{banker_dado2}]",
        "Banker Soma": banker_sum,
        "Vencedor": winner, # Esta √© a chave correta!
        "Timestamp": datetime.datetime.now().strftime("%H:%M:%S")
    })
    
    # Atualiza contadores de hor√°rios cr√≠ticos
    atualizar_contadores_horarios(player_dado1, player_dado2, banker_dado1, banker_dado2, winner)

    # Exibe uma mensagem de sucesso
    st.success(f"Rodada {len(st.session_state.historico)} adicionada! Vencedor: {winner}")
    # For√ßa uma re-execu√ß√£o para atualizar a sugest√£o imediatamente
    st.experimental_rerun()

st.markdown("---")

# --- An√°lise de Hor√°rios Cr√≠ticos ---
st.header("‚è∞ An√°lise de Hor√°rios Cr√≠ticos")

# L√≥gica para "Hor√°rios Ruins"
horario_ruim = False
# Crit√©rio 1: 3 empates em menos de 10 rodadas (necessita de um controle mais sofisticado, este √© um placeholder)
if st.session_state.empates_recentes >= 3 and len(st.session_state.historico) <= 10 and len(st.session_state.historico) > 0:
    st.warning("‚ö†Ô∏è **Cuidado:** Novo baralho com muitos empates iniciais. Sugerimos cautela.")
    horario_ruim = True
# Crit√©rio 2: Dado '1' em 5 rodadas seguidas
if st.session_state.count_dado_1_consecutivo >= 5:
    st.warning("‚ö†Ô∏è **Aten√ß√£o:** Dado '1' apareceu em 5 rodadas seguidas. Potencial de manipula√ß√£o ou momento ruim.")
    horario_ruim = True
# Crit√©rio 3: Mesa travando ou delay (depende de feedback manual do usu√°rio ou detec√ß√£o avan√ßada)
# Voc√™ pode adicionar um bot√£o para o usu√°rio reportar isso:
# if st.button("Mesa com Lag/Problemas"):
#    st.error("üö® Problemas na mesa detectados. Sugest√µes desativadas.")
#    horario_ruim = True

if not horario_ruim and len(st.session_state.historico) > 0:
    st.info("No momento, n√£o h√° indica√ß√£o de hor√°rios ruins baseados em padr√µes simples. Continue monitorando.")

# L√≥gica para "Hor√°rios Bons"
horario_bom = False
# Crit√©rio 1: Vit√≥rias seguidas do mesmo lado com margens 1 ou 2 (requer l√≥gica de margem)
# Placeholder para este padr√£o
# if st.session_state.sequencia_vitorias_margem_1_ou_2 >= 3:
#    st.success("‚úÖ Bom momento: Sequ√™ncia de vit√≥rias com margem 1 ou 2. Mantenha o foco!")
#    horario_bom = True
# Crit√©rio 2: Empates sumindo por mais de 15 rodadas
if st.session_state.rodadas_desde_ultimo_empate > 15 and len(st.session_state.historico) > 0:
    st.success("‚úÖ **Excelente:** Aus√™ncia prolongada de empates. Oportunidade de padr√µes claros.")
    horario_bom = True
# Crit√©rio 3: Padr√£o Ouro se formando (detectado pela fun√ß√£o analisar_sugestao)

if not horario_bom and len(st.session_state.historico) > 0:
    if not horario_ruim: # N√£o mostrar mensagem redundante se j√° for ruim
        st.info("No momento, n√£o h√° indica√ß√£o de hor√°rios especialmente bons.")


st.markdown("---")

# --- Sugest√£o de Entrada Inteligente ---
st.header("üéØ Sugest√£o de Entrada")

# Analisa e obt√©m a sugest√£o
nome_padrao_sugerido, entrada_sugerida, confianca, is_g1_active = analisar_sugestao(st.session_state.historico)

# Verifica se o app deve sugerir ou bloquear devido a hor√°rios ruins
if horario_ruim:
    st.warning("üö´ **Sugest√µes Bloqueadas:** O aplicativo est√° em um hor√°rio cr√≠tico (ruim). N√£o √© recomendado fazer entradas.")
elif entrada_sugerida:
    st.session_state.last_suggested_entry = entrada_sugerida # Salva a √∫ltima sugest√£o para o G1
    with st.expander("Ver Sugest√£o Detalhada", expanded=True): # Come√ßa expandido para visibilidade
        st.subheader(f"üéâ Entrada Sugerida!")
        st.write(f"**Padr√£o Detectado:** {nome_padrao_sugerido}")
        st.markdown(f"**Entrada Sugerida:** {'<span style="color:blue; font-size: 20px;">üîµ PLAYER</span>' if entrada_sugerida == 'Player' else '<span style="color:red; font-size: 20px;">üî¥ BANKER</span>'}", unsafe_allow_html=True)
        st.write(f"**Confian√ßa:** **{confianca:.0f}%**")
        
        if is_g1_active:
            st.warning("üö® **Status:** Modo G1 Ativo! Mantenha a entrada anterior.")
        else:
            st.info("‚úÖ **Status:** Normal")

        # Bot√µes de Feedback
        col_feedback1, col_feedback2, col_feedback3 = st.columns(3)
        with col_feedback1:
            if st.button("‚úÖ GREEN (Acertou)", use_container_width=True):
                st.session_state.green_count += 1
                st.session_state.g1_active = False # Desativa G1 se acertou
                st.session_state.last_suggested_entry = None # Reseta a sugest√£o G1
                st.success("üéâ Parab√©ns! GREEN!")
                st.experimental_rerun() # Re-executa para atualizar os contadores
        with col_feedback2:
            if st.button("‚ùå RED (Errou)", use_container_width=True):
                st.session_state.red_count += 1
                st.session_state.g1_active = True # Ativa G1 se errou
                st.error("üò• Que pena! RED. G1 ativado para a pr√≥xima entrada.")
                st.experimental_rerun() # Re-executa para atualizar os contadores
        with col_feedback3:
            if st.button("üü° EMPATE", use_container_width=True):
                st.info("Rodada foi um empate. Contadores de GREEN/RED e G1 n√£o alterados.")
                st.experimental_rerun() # Re-executa para atualizar a interface
else:
    st.info("Aguardando mais dados ou padr√µes de alta confian√ßa para sugerir uma entrada. Continue adicionando rodadas!")


st.markdown("---")

# --- Painel de Hist√≥rico e Estat√≠sticas ---
st.header("üìà Painel de Resultados")

# Estat√≠sticas
col_stats1, col_stats2, col_stats3 = st.columns(3)
with col_stats1:
    st.metric(label="üíö GREEN (Acertos)", value=st.session_state.green_count)
with col_stats2:
    st.metric(label="üíî RED (Erros)", value=st.session_state.red_count)
with col_stats3:
    total_jogadas = st.session_state.green_count + st.session_state.red_count
    if total_jogadas > 0:
        win_rate = (st.session_state.green_count / total_jogadas) * 100
        st.metric(label="üìä Taxa de Acerto", value=f"{win_rate:.2f}%")
    else:
        st.metric(label="üìä Taxa de Acerto", value="N/A")

# Hist√≥rico Detalhado
st.subheader("üìú Hist√≥rico de Rodadas")
if st.session_state.historico:
    # Cria um DataFrame para exibir o hist√≥rico de forma mais organizada
    # Garante que o hist√≥rico seja exibido em ordem reversa (mais recente primeiro)
    df_historico = pd.DataFrame(st.session_state.historico[::-1])
    st.dataframe(df_historico.set_index('Rodada'), use_container_width=True)
else:
    st.info("Nenhuma rodada adicionada ainda. Use o painel acima para come√ßar.")

# Bot√£o para limpar o hist√≥rico (√∫til para testes ou recome√ßar)
st.markdown("---")
if st.button("üîÑ Limpar Hist√≥rico e Resetar Contadores"):
    st.session_state.historico = []
    st.session_state.green_count = 0
    st.session_state.red_count = 0
    st.session_state.g1_active = False
    st.session_state.last_suggested_entry = None
    st.session_state.rodadas_desde_ultimo_empate = 0
    st.session_state.empates_recentes = 0
    st.session_state.count_dado_1_consecutivo = 0
    st.experimental_rerun() # Re-executa para limpar a tela
